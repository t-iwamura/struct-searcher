import json
import re
from pathlib import Path
from typing import List, Optional

import numpy as np
from numpy.typing import NDArray
from pymatgen.core import Lattice, Structure

from struct_searcher.data import load_atom_info
from struct_searcher.struct import (
    convert_lattice_constants_to_niggli_cell,
    convert_niggli_cell_to_lattice_constants,
    convert_niggli_cell_to_system_params,
    create_niggli_cell,
    has_enough_space_between_atoms,
)

POTENTIALS_DIR_PATH = Path.home() / "struct-searcher" / "data" / "inputs" / "potentials"


def read_elements(
    system_name: str, potentials_dir_path: Optional[Path] = None
) -> List[str]:
    """Read elements in the order defined in mlp.lammps

    Args:
        system_name (str): The name of a system.
        potentials_dir_path (Optional[Path], optional):
            Path object of potentials directory. Defaults to None.

    Returns:
        List[str]: The elements keeping the order.
    """
    if potentials_dir_path is None:
        potentials_dir_path = POTENTIALS_DIR_PATH

    # Read IDs of recommended potentials
    potential_id_json_path = potentials_dir_path / "potential_id.json"
    with potential_id_json_path.open("r") as f:
        potential_ids = json.load(f)

    # Read elements from mlp.lammps
    potential_file_path = (
        potentials_dir_path / system_name / potential_ids[system_name] / "mlp.lammps"
    )
    with potential_file_path.open("r") as f:
        first_line = f.readline()

    elements = []
    for item in first_line.split():
        if item == "#":
            break

        elements.append(item)

    return elements


def create_lammps_struct_file(
    xhi: float,
    yhi: float,
    zhi: float,
    cart_coords: NDArray,
    elements: List[str],
    n_atom_for_each_element: List[int],
    xy: float = 0.0,
    xz: float = 0.0,
    yz: float = 0.0,
) -> str:
    """Create structure file for LAMMPS

    Args:
        xhi (float): The parameter about system.
        yhi (float): The parameter about system.
        zhi (float): The parameter about system.
        cart_coords (NDArray): The cartesian coordinates of all the atoms.
            The shape is (n_atom, 3).
        elements (List[str]): List of element included in system.
        n_atom_for_each_element (List[int]): The number of atoms for each element.
        xy (float, optional): The tilt parameter Defaults to 0.0.
        xz (float, optional): The tilt parameter Defaults to 0.0.
        yz (float, optional): The tilt parameter Defaults to 0.0.

    Returns:
        str: The content of a structure file.
    """
    # Remove elements which don't exist
    elements = [
        e for e, n_atom in zip(elements, n_atom_for_each_element) if n_atom != 0
    ]
    n_atom_for_each_element = [n for n in n_atom_for_each_element if n != 0]

    # Create system section
    n_atom = cart_coords.shape[0]
    n_type = len(n_atom_for_each_element)
    lines = [
        "# generated by struct-searcher",
        "",
        f"{n_atom} atoms",
        f"{n_type} atom types",
        "",
        f"0.0 {xhi:.15f} xlo xhi",
        f"0.0 {yhi:.15f} ylo yhi",
        f"0.0 {zhi:.15f} zlo zhi",
        "",
    ]

    if xy != 0.0 or xz != 0.0 or yz != 0.0:
        lines.append(f"{xy:.15f} {xz:.15f} {yz:.15f} xy xz yz")
        lines.append("")

    # Create Masses section
    masses_section = ["Masses", ""]
    atom_info = load_atom_info()
    for i, e in enumerate(elements, 1):
        masses_section.append(f"{i} {atom_info[e]['mass']:.8f}")
    masses_section.append("")

    # Create type list for all the atoms
    types = [
        i for i, n_atom in enumerate(n_atom_for_each_element, 1) for _ in range(n_atom)
    ]

    # Create Atoms section
    atoms_section = ["Atoms", ""]
    for i, (atom_type, coords) in enumerate(zip(types, cart_coords.tolist()), 1):
        coords_str = " ".join("{:.15f}".format(coord) for coord in coords)
        line = f"{i} {atom_type} {coords_str}"
        atoms_section.append(line)
    atoms_section.append("")

    lines.extend(masses_section)
    lines.extend(atoms_section)
    content = "\n".join(lines)

    return content


def create_lammps_struct_file_from_structure(structure: Structure) -> str:
    """Create structure file for LAMMPS from Structure object

    Args:
        structure (Structure): Object representing a structure.

    Returns:
        str: The content of a structure file.
    """
    # Ensure elements in a structure are sorted
    structure.sort()

    # Create system parameters
    a, b, c, alpha, beta, gamma = structure.lattice.parameters
    niggli = convert_lattice_constants_to_niggli_cell(a, b, c, alpha, beta, gamma)
    system_params = convert_niggli_cell_to_system_params(niggli)

    # Convert fractional coordinates to cartesian coordinates
    cart_coords = structure.frac_coords @ structure.lattice.matrix

    # Create objects related to elements
    species = [e.symbol for e in structure.species]
    elements = list(set(species))
    n_atom_for_each_element = [species.count(e) for e in elements]

    content = create_lammps_struct_file(
        system_params["xhi"],
        system_params["yhi"],
        system_params["zhi"],
        cart_coords,
        elements,
        n_atom_for_each_element,
        system_params["xy"],
        system_params["xz"],
        system_params["yz"],
    )
    return content


def create_sample_struct_file(
    g_max: float, elements: List[str], n_atom_for_each_element: List[int]
) -> str:
    """Create sample structure file

    Args:
        g_max (float): The parameter to control volume maximum.
        elements (List[str]): List of element included in system.
        n_atom_for_each_element (List[int]): The number of atoms for each element.

    Returns:
        str: The content of sample structure file.
    """
    cnt = 0
    g_min = 0.0
    while True:
        # Create Niggli reduced cell
        niggli = create_niggli_cell(g_max, g_min)

        # Check that the volume of Niggli cell isn't too large
        a, b, c, alpha, beta, gamma = convert_niggli_cell_to_lattice_constants(niggli)
        lattice = Lattice.from_parameters(a, b, c, alpha, beta, gamma)
        if lattice.volume >= g_max ** (3 / 2):
            continue

        # Create fractional coordinates of atoms
        n_atom = sum(n_atom_for_each_element)
        frac_coords = np.random.rand(n_atom, 3)
        frac_coords[0, :] = 0.0

        if n_atom == 1:
            break

        if has_enough_space_between_atoms(
            lattice, frac_coords, elements, n_atom_for_each_element
        ):
            break
        elif cnt < 1000:
            cnt += 1
            g_min = (cnt / 1000) * g_max

    system_params = convert_niggli_cell_to_system_params(niggli)

    # Convert fractional coordinates to cartesian coordinates
    lattice_matrix = np.array(
        [
            [system_params["xhi"], system_params["xy"], system_params["xz"]],
            [0.0, system_params["yhi"], system_params["yz"]],
            [0.0, 0.0, system_params["zhi"]],
        ]
    )
    cart_coords = frac_coords @ lattice_matrix.T

    content = create_lammps_struct_file(
        system_params["xhi"],
        system_params["yhi"],
        system_params["zhi"],
        cart_coords,
        elements,
        n_atom_for_each_element,
        system_params["xy"],
        system_params["xz"],
        system_params["yz"],
    )
    return content


def create_static_lammps_command_file(
    potential_file: str,
    elements: List[str],
    n_atom_for_each_element: List[int],
    struct_file: str,
) -> str:
    """Create LAMMPS command file for static calculation

    Args:
        potential_file (str): Path to a potential file.
        elements (List[str]): List of element included in system.
        n_atom_for_each_element (List[int]): The number of atoms for each element.
        struct_file (str): Path to a structure file.

    Returns:
        str: The content of LAMMPS command file.
    """
    # Choose the element which exists
    elements_str = " ".join(
        e for e, n in zip(elements, n_atom_for_each_element) if n != 0
    )

    lines = [
        "units metal",
        "box tilt large",
        "atom_style atomic",
        "",
        "boundary m m m",
        f"read_data {struct_file}",
        "",
        "pair_style polymlp",
        f"pair_coeff * * {potential_file} {elements_str}",
        "",
    ]
    content = "\n".join(lines)

    return content


def create_lammps_command_file(
    potential_file: str,
    elements: List[str],
    n_atom_for_each_element: List[int],
    output_dir_path: Path,
    ftol: float,
    relaxation_id: str = "01",
    input_dir_path: Optional[Path] = None,
) -> str:
    """Create lammps command file

    Args:
        potential_file (str): The path of mlp.lammps.
        elements (List[str]): List of element included in system.
        n_atom_for_each_element (List[int]): The number of atoms for each element.
        output_dir_path (Path): Path object of output directory.
        ftol (float): The tolerance for global force vector.
        relaxation_id (str, optional): The ID of relaxation. Defaults to '01'.
        input_dir_path (Optional[Path], optional): Object of input directory.
            Defaults to None.

    Returns:
        str: The content of lammps command file.
    """
    if input_dir_path is None:
        input_dir_path = output_dir_path

    # Convert relative path to absolute path
    potential_file = str(Path(potential_file).resolve())
    initial_struct_file = str(
        input_dir_path.resolve() / f"initial_structure_{relaxation_id}"
    )
    final_struct_file = str(
        output_dir_path.resolve() / f"final_structure_{relaxation_id}"
    )

    # Choose the element which exists
    elements_str = " ".join(
        e for e, n in zip(elements, n_atom_for_each_element) if n != 0
    )

    # Settings about relaxation
    etol = 0.0
    maxiter = 5000
    maxeval = 50000
    pressure = 0.0

    lines = [
        "units metal",
        "box tilt large",
        "atom_style atomic",
        "",
        "boundary p p p",
        f"read_data {initial_struct_file}",
        "",
        "pair_style polymlp",
        f"pair_coeff * * {potential_file} {elements_str}",
        "",
        "# What to monitor during minimization",
        "thermo 1",
        "thermo_style custom step temp pe etotal press fnorm",
        "thermo_modify norm yes",
        "",
        "# Rebuild neighbor list at every timestep",
        "neigh_modify delay 0 every 1 check yes one 100000 page 1000000",
        "",
    ]

    n_atom = sum(n_atom_for_each_element)
    if n_atom < 10:
        relaxation_section = [
            "# Do relaxation with a bunch of degrees of freedom",
            f"fix ftri all box/relax tri {pressure}",
            f"minimize 0.0 {ftol} {maxiter} {maxeval}",
            "",
        ]
    else:
        relaxation_section = [
            "# Move atoms only",
            f"minimize {etol} {ftol} {maxiter} {maxeval}",
            "reset_timestep 0",
            "",
            "# Do isotropic volume relaxation",
            f"fix fiso all box/relax iso {pressure}",
            f"minimize {etol} {ftol} {maxiter} {maxeval}",
            "unfix fiso",
            "reset_timestep 0",
            "",
            "# Do anisotropic volume relaxation without shear",
            f"fix faniso all box/relax aniso {pressure}",
            f"minimize {etol} {ftol} {maxiter} {maxeval}",
            "unfix faniso",
            "reset_timestep 0",
            "",
            "# Do anisotropic volume relaxation with shear",
            f"fix ftri all box/relax tri {pressure}",
            f"minimize {etol} {ftol} {maxiter} {maxeval}",
            "unfix ftri",
            "reset_timestep 0",
            "",
        ]

    save_section = [
        "# Output final structure",
        f"write_data {final_struct_file}",
        "",
    ]

    lines.extend(relaxation_section)
    lines.extend(save_section)
    content = "\n".join(lines)

    return content


def create_job_script(
    job_name: str, first_sid: int, relax_once: bool = False, output_dir_id: str = "01"
) -> str:
    """Create job script

    Args:
        job_name (str): The name of a job.
        first_sid (int): The ID of first structure.
        relax_once (bool, optional): Whether to relax just once or not.
            Defaults to False.
        output_dir_id (str, optional): The ID of output directory. Defaults to '01'.

    Returns:
        str: The content of a job script.
    """
    # Create pattern of sample structure directories
    n_structure = 1000
    last_sid = first_sid + n_structure - 1
    dir_pattern = "".join(
        ["{", str(first_sid).zfill(5), "..", str(last_sid).zfill(5), "}"]
    )
    if relax_once:
        command = (
            f"struct-searcher relax-by-mlp {dir_pattern} --once "
            f"--output_dir_id {output_dir_id}"
        )
    else:
        command = f"struct-searcher relax-by-mlp {dir_pattern}"

    lines = [
        "#!/bin/zsh",
        f"#SBATCH -J {job_name}",
        "#SBATCH --nodes=1",
        "#SBATCH -e err.log",
        "#SBATCH -o std.log",
        "#SBATCH --open-mode=append",
        "",
        ". ~/.zprofile",
        ". ~/.zshrc",
        "pyenv activate structural_search",
        command,
        "",
    ]
    content = "\n".join(lines)

    return content


def parse_lammps_log(log_file: str) -> str:
    """Parse LAMMPS log file

    Args:
        log_file (str): The path to log.lammps.

    Returns:
        str: The result status of LAMMPS calculation.
    """
    success_pattern = re.compile(r".*Stopping criterion = +force +tolerance.*")
    alpha_pattern = re.compile(r".*Stopping criterion = .+(is|are) +zero.*")
    result_status = "UNFINISHED"
    with open(log_file) as f:
        for line in f:
            if success_pattern.match(line):
                result_status = "SUCCESS"
                break
            elif alpha_pattern.match(line):
                result_status = "ALPHA"
                break

    return result_status
